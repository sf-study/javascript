##创建对象

使用object构造函数或对象字面量都可以用来创建单个对象，但是这两种方式有个明显的缺点，使用同一个接口创建很多对象，会产生大量的重复代码

###工厂模式

用函数来封装以特定接口创建对象的细节

```javascript
function oa1(n,a,j){
	var o=new Object();
	o.name=n;
	o.age=a;
	o.sayName=function(){
		console.log(this.name);
	};
	return o;
}
var a1=oa1("xinxin",23,"sss");
var a2=oa1("dd",22,"ddd");
console.log(a1.name);//xinxin
console.log(a2.age);//22
```

该方法带来了一个新的问题：怎样知道一个对象的类型

###构造函数模式

```javascript
function Oa2(n,a,j){
	this.name=n;
	this.age=a;
	this.job=j;
	this.sayName=function(){
		console.log(this.name);
	};
}
var b1=new Oa2("xinxin",23,"sss");
var b2=new Oa2("dd",22,"ddd");
console.log(b1.name);//xinxin
console.log(b2.age);//22

console.log(b1.constructor==Oa2);//true
console.log(b2.constructor==Oa2);//true
console.log(b1 instanceof Object);//true
console.log(b1 instanceof Oa2);//true
```

这段代码与工厂模式的代码不同的地方有：
+ 没有显式的创建对象    
+ 直接将属性和方法赋值给了this对象    
+ 没有return语句    
+ 函数名首字母大写

构造函数模式创建的实例每个实例都有一个constructor属性，该属性指向构造函数，使用这种方法可以检测某各实例是否属于某各类型


检测对象类型：instanceof 操作符，检测对象是否属于某各类型


每个对象都是Object类型的实例，上面代码已验证，因为所有的对象均继承Object实例

####构造函数的问题

每个方法都要在每个实例上重新创建一遍

以这种方式创建的函数，会导致不同的作用域和标识符解析

**解决方法：**

```javascript
function sayName(){
	console.log(this.name);
}
function Oa3(n,a,j){
	this.name=n;
	this.age=a;
	this.job=j;
	this.sayName=sayName;
}
```

把sayname方法写在构造函数外面，但是使用这种方法，假如一个对象需要定义好多方法，就会导致我们也要同时定义好多全局函数。

###原型模式

创建的每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法，使用原型对象的好处是可以让所有的对象实例共享它所包含的属性和方法

	function Ps3(){
		
	}
	Ps3.prototype.name='xinxin';
	Ps3.prototype.age=22;
	Ps3.prototype.job='se';
	Ps3.prototype.sayname=function(){
		alert(this.name);
	};
	var p3=new Ps3();
	p3.sayname();

