##继承

原型链是实现继承的主要方法

##原型链

让子类的原型对象对于父类的实例，如此一来，子类的prototype属性所指向的原型对象里面就包含一个内部属性[[prototype]]，该属性又指向父类的原型对象，所以也就继承了父类原型对象的原型方法

```javascript
//父类
function SuperOa(){
	this.property=true;
}
SuperOa.prototype.getSuperValue=function(){
	return this.property;
};

//子类
function SubOa(){
	this.subproperty=false;
}
//继承父类
SubOa.prototype=new SuperOa();

//子类的原型方法
SubOa.prototype.getSubValue=function(){
	return this.subproperty;
};

//实例
var instance=new SubOa();
console.log(instance.getSuperValue());//true
```

###默认的原型

所有函数的默认原型都是Object的实例

###定义方法

子类有的时候需要重写超类中的某个方法，或者需要添加超类中没有的方法，不管如何，给原型添加方法的代码一定要放在替换子类原型的语句之后

```javascript
//父类
function SuperOb(){
	this.property="超类属性";
}
SuperOb.prototype.getSuperValue=function(){
	return this.property;
};

//子类
function SubOb(){
	this.subproperty="子类属性";
}
//继承父类
SubOb.prototype=new SuperOb();

//子类的原型方法
SubOb.prototype.getSubValue=function(){
	return this.subproperty;
};
//重写超类中的方法
//会屏蔽原来超类中的方法
SubOb.prototype.getSuperValue=function(){
	return "在子类重写后的超类方法";
};

//实例
var b=new SubOb();
console.log(b.getSuperValue());//在子类重写后的超类方法
var b1=new SuperOb();
console.log(b1.getSuperValue());//超类属性
```

在子类中重新定义超类中的方法，通过子类的实例访问该方法，访问的是重写后的方法。但是通过超类的实例访问该方法，访问的是没有重写之前的方法。`这是因为访问一个方法是向上搜索原型链的`

###注意

在通过原型链实现继承的时候，不能使用字面量创建原型的方法。因为这样会重写原型链

###原型链的问题

```javascript
//父类
function SuperOc(){
	this.property="超类属性";
	this.colors=["red","blue","green"];
}
SuperOc.prototype.getSuperValue=function(){
	return this.property;
};

//子类
function SubOc(){
	this.subproperty="子类属性";
}
//继承父类
SubOc.prototype=new SuperOc();

//子类的原型方法
SubOc.prototype.getSubValue=function(){
	return this.subproperty;
};

//实例
var c1=new SubOc();
c1.colors.push("black");
console.log(c1.colors);//["red", "blue", "green", "black"]
var c1=new SubOc();
console.log(c1.colors);//["red", "blue", "green", "black"]
```

问题1：因为通过原型链继承，父类的实例属性，会自动成为子类的原型属性，当该属性是应用类型值的时候，子类的实例会共享该属性

问题2：创建子类的时候，没有办法在不影响所有对象实例的情况下向超类的构造函数中传递参数