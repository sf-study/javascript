##DOM扩展

##目录

###选择符API

* [querySelector()方法](#a1)

* [querySelectorAll()方法](#a2)

* [matchesSelector()方法](#a3)

###元素遍历

* [元素遍历](#a4)

###HTML5

* [HTML5 getElementsByClassName（）](#a5)

* [classList属性](#a6)

* [焦点管理](#a7)

* [HTMLDocument的变化](#a8)

* [字符集属性](#a9)

* [自定义数据属性](#a10)

* [插入标记](#a11)

* [专有扩展](#a12)

##选择符API

###选择符API一级的两个核心方法：querySelector()，querySelectorAll()

**兼容浏览器：IE8+，Firefox3.5+，Safari3.1+，Chrome，Opera10+**

<a name="a1"></a>

###querySelector()方法

该方法接受一个CSS选择符，返回与该模式匹配的第一个元素的引用，如果没有找到匹配的元素，返回NULL

可以通过element,document等调用该方法

```html
<div class="div1">
	this is div1
</div>
<script type="text/javascript">
	var div1=document.querySelector(".div1");
	console.log(div1.innerHTML);//this is div1
</script>
```

<a name="a2"></a>

###querySelectorAll()方法

该方法接受一个CSS选择符，返回与该模式匹配的所有元素的NodeList实例，并且可以通过[]或item()法访问列表中的项

可以通过element,document，documentFragment等DOM类型调用该方法

```html
<ul class="ul1">
	<li>111</li>
	<li>222</li>
	<li>333</li>
</ul>
<script type="text/javascript">
	var ul1=document.querySelector(".ul1");
	var lis=ul1.querySelectorAll(".ul1 li");
	console.log(lis[0].innerHTML);//111
	console.log(lis.item(1).innerHTML);//222
</script>
```

<a name="a3"></a>

###选择符二级为Element类型新增了一个方法：matchesEelector()。

该方法接受一个css选择符作为参数，如果调用元素与与参数匹配，返回true，否则返回false

```html
<div class="div2" id="div2">
	this is div2
</div>
<script type="text/javascript">
    function matchesSelector(ele, sel) {
        if (ele.matchesSelector) {
            return ele.matchesSelector(sel);
        } else if (ele.msMatchesSelector) {
            return ele.msMatchesSelector(sel);
        } else if (ele.mozMatchesSelector) {
            return ele.mozMatchesSelector(sel);
        } else if (ele.webkitMatchesSelector) {
            return ele.webkitMatchesSelector(sel);
        } else {
            throw new Error('not supported');
        }
    }
    
    var div2 = document.querySelector(".div2");
    if(matchesSelector(div2,"#div2")){
    	console.log(div2.innerHTML);//this is div2
    }
</script>
```

<a name="a4"></a>

###元素遍历

对于元素之间的空格，IE9集之前的版本不会返回文本节点，而其他所有浏览器都会返回文本节点，也就是把空格也当作文本节点返回

为了避免有些浏览器将空格当成文本节点返回，Element traversal API 定义了五个属性：（注意这五个属性都是DOM元素的属性）

**浏览器兼容：IE9+，Firefox3.5+，Safari4+，Chrome，Opera10+**

+ childElementCount ，返回子元素的个数（不包括空文本节点和注释）

+ firstElementChild,指向第一个子元素

+ lashElementChild，指向最后一个子元素

+ previousElementSibling，指向前一个同辈元素

+ nextElementSibling，指向后一个同辈元素

<a name="a5"></a>

##HTML5 DOM

###getElementsByClassName（）

该方法接受一个参数，即包含一个或多个类名的字符串，并返回指定类的所有元素的Nodelist

可以通过document对象以及所有HTML元素调用该方法

**浏览器兼容：IE9+，Firefox3+，Safari3.1+，Chrome，Opera9.5+**

```html
<div id="div3">
	<p class="div3_p">123</p>
	<p class="div3_p">456</p>
	<p class="div3_p">789</p>
</div>
<script type="text/javascript">
	var div3=document.getElementById("div3");
	var p3s=div3.getElementsByClassName("div3_p");
	console.log(p3s[0].innerHTML);//123
</script>
```

<a name="a6"></a>

###classList属性

	/*
	 * 传统方法操作类名（ie9+）
	 */
	var td0=document.getElementsByClassName('c4 c5 c6');
	var cn=td0[0].className.split(/\s/);
	var pos=-1,i,len;
	for(i=0,len=cn.length;i<len;i++){
		if(cn[i]=='c4'){
			pos=i;
			break;
		}
	}
	cn.splice(i,1);
	td0.className=cn.join("");

HTML5新增的操作类名的方式，为所有的元素添加classList属性

该属性有length属性，并且可以通过item()或者[]访问列表中的项，除此之外该方法还定义如下方法

+ add(value)：将给定的字符串添加到列表中，如果值已经存在，就不添加

+ contains(value):表示列表中是否存在给定的值，如果存在返回true，否则返回false

+ remove(value):从列表中删除给定的字符串

+ toggle(value):如果列表中已经存在给定的值，删除它，如果列表中没有给定的值，添加之

```html
<div id="div4" class="div4 s1 s2 s3">
	this is div4
</div>
<script type="text/javascript">
	var div4=document.getElementById("div4");
	var classlist=div4.classList;
	console.log(classlist);//["div4", "s1", "s2", "s3"]
	classlist.remove("s1");
	console.log(classlist);//["div4", "s2", "s3"]
	classlist.add("s4");
	console.log(classlist);//["div4", "s2", "s3", "s4"]
	console.log(classlist.contains("div4"));//true
	classlist.toggle("s5");
	console.log(classlist);//["div4", "s2", "s3", "s4", "s5"]
</script>
```

**浏览器兼容：Firefox3.6+，Chrome**

<a name="a7"></a>

###焦点管理

document.activeElement属性，始终引用当前DOM中获得焦点的元素

当文档刚加载完成时document.activeElement中保存的是document.body元素的引用，
当文档加载期间，document.activeElement的值为null

hasFocus()方法用于确定文档是否获得了焦点

**浏览器兼容：ie4+，firefox3+,safari4+,chrome,opera8+**

<a name="a8"></a>

###HTMLDocument的变化

####document.readyState

document.readyState属性指示文档是否加载完成，该属性有两个可能的值：loading(正在加载文档)，complete(已经加载完文档)

**浏览器兼容：ie4+，firefox3.6+,safari,chrome,opera9+**

####兼容模式

document.compatMode属性告诉开发者浏览器采用了哪种渲染模式，在标准模式下document.compatMode的值等于CSS1Compat，在混杂模式下document.compatMode的值等于BackCompat

**浏览器兼容：ie6+，firefox,safari3.1,chrome,opera**

####head属性

HTML5新增了document.head属性，引用head元素

```html
<script type="text/javascript">
	var head=document.head||document.getElementsByTagName("head")[0];
</script>
```

**浏览器兼容：safari5+,chrome**

<a name="a9"></a>

###字符集属性

	/*
	 * document.charset，获得文档的编码方式
	 * ie，safari,chrome,opera
	 * document.defaultCharset，浏览器的默认编码
	 * ie，safari,chrome
	 */
	document.writeln(document.charset);
	document.charset='utf-8';
	document.writeln(document.defaultCharset);

<a name="a10"></a>

###自定义数据属性

	/*
	 * dataset访问自定义属性，dataset是DOMStringMap的一个实例
	 */
	myd=document.querySelector('.data');
	document.writeln(myd.dataset.myshuxing);
	myd.dataset.sx='xinxin';

<a name="a11"></a>

###插入标记

####innerHTML属性

不支持的属性col,colgroup,frameset,head,html,style,table,tbody,thead,tfoot,tr

	/*
	 * innerHTML属性读取模式下返回调用该属性的所有子元素节点，包括注释节点，
	 * 写入模式下，传入的值被解析为DOM子树，替换调用元素的所有子节点
	 */
	alert(document.body.innerHTML);
	var cs1=document.querySelector('.c10');
	cs1.innerHTML='hhhhhhh';
	cs1.innerHTML="<a href='#'>测试</a>";//改属性可以解析HTML代码
	/*
	 * 下面的一行，不会被解析，<script>元素被认为是无作用域的元素，即页面中
	 * 看不到的元素,相同的元素还有注释等元素，如果innerHTML的值
	 * 是一个无作用域的元素，这个值会被解析为空字符串
	 */
	cs1.innerHTML="<script type='text/javascript' defer>alert('hi);<\/script>";
	/*
	 * 想让上面的代码能被解析，正常运行，需要给无作用域的元素前面加一个有作用域的元素标签
	 */
	cs1.innerHTML="_<script type='text/javascript'>alert('hi);<\/script>";
	cs1.innerHTML="<div>&nbsp;</div><script type='text/javascript'>alert('hi);<\/script>";
	/*
	 * 大部分浏览器支持下面的第一行代码，ie8及以下不支持，因为在ie8一下浏览器认为<style>
	 * 是没有作用域的元素,解决办法可以像上面的<script>一样
	 */
	cs1.innerHTML="<style type=\'text/css\'>body{background-color:green;}</style>";
	cs1.innerHTML="_<style type=\'text/css\'>body{background-color:green;}</style>";

####outerHTML属性

	/*
	 * outerHTML属性读取模式下返回调用它的元素的以及调用元素的
	 * 所有后代节点的html标签,在写入模式下，接受一个字符串参数，
	 * 然后把参数解析为HTML代码，替换调用的元素
	 * ie4+，firefox8+,safari4+,chrome,opera8+
	 */
	var outh=document.querySelector('.outerhtml .box');
	// alert(outh.outerHTML);
	outh.outerHTML="<div class='tihuanbox'>替换节点</div>";

###insertAdjacentHTML()方法

	/*
	 * insertAdjacentHTML()方法，在指定位置插入代码
	 * ie，firefox8+,safari,chrome,opera8+
	 */
	var iah=document.querySelector('.iah .iahbox');
	iah.insertAdjacentHTML('beforebegin','<p>你好，beforebegin，在调用元素的前面插入一个同辈的元素</p>');
	iah.insertAdjacentHTML('afterbegin','<p>你好，afterbegin，将字符串插入到调用元素的第一个子元素</p>');
	iah.insertAdjacentHTML('beforeend','<p>你好，beforeend，将字符串插入到调用元素的最后一个子元素</p>');
	iah.insertAdjacentHTML('afterend','<p>你好，afterend，在调用元素的后面插入一个同辈的元素</p>');

####scrollIntoView（）方法

	/*
	 * scrollIntoView（）方法让元素可见
	 * 该方法接受一个布尔值参数
	 * true/无参数：调用元素的顶部与视口顶部尽可能平齐
	 * false：调用元素尽可能全部出现在视口中
	 * ie，firefox,safari,opera
	 */
	var scroll=document.querySelector('.scroll');
	scroll.scrollIntoView(true);

<a name="a12"></a>

###专有扩展

####documentMode文档模式

	/*
	 * 判断ie的渲染模式
	 */
	var mode=document.documentMode;
	document.writeln(mode);

####children属性

	/*
	 * children属性，为了解决ie9之前的版本在处理空文本节点时候的差异
	 * ie5+，firefox3.5,safari2（有bug）,safari3，opera8,chrome
	 */
	var childc=document.querySelector('.ul0 ul').children.length;
	document.writeln(childc);

####contains（）

	/*
	 * 测试括号里面的元素是不是调用元素的后代
	 * ie,firefox9+,safari,opera,chrome
	 */
	var ul0=document.getElementById('ulid');
	document.body.contains(ul0);
	
	/*
	 * compareDocumentPosition()方法
	 * 返回关系掩码：
	 * 1：无关
	 * 2：居前
	 * 4：居后
	 * 8：包含
	 * 16：被包含
	 * ie9+,firefox,safari,opera9.5+,chrome
	 */
	var r1=document.body.compareDocumentPosition(ul0);
	var r2=ul0.compareDocumentPosition(document.body);
	alert(!!(r1&16));
	/*
	 * 通用方法
	 */
	var body=document.body;
	function contain(refnode,othernode){
		if(typeof refnode.contains=='function'&&(!client.engine.webkit || client.engine.webkit>=522)){
			return refnode.contains(othernode);
		}else if(typeof refnode.compareDocumentPosition=='function'){
			return !!(refnode.compareDocumentPosition(othernode));
		}else{
			var node=othernode.parentNode;
			do{
				if(node===refnode){
					return true;
				}else{
					node=node.parentNode;
				}
			}while(node!==null);
			return false;
		}
	}
	var result=contain(body,ul0);

###插入文本

* innerText属性     

* 读取模式：将字文档树中的所有文本拼接起来     

* 写入模式：     
* 删除调用元素的所有子节点，插入值     

* ie4+,safari3+,opera8+,chrome     

	
	下面的值不会被解析成html代码插入，
	con1.innerText="你好<b>\'reader\'</b>";

* Firefox支持textContent

* 还有ie9+,safari3+,opera10+,chrome

**通用方法**

	function getInnerText(ele){
		return(typeof ele.textContent=='string')?ele.textContent:ele.innerText;
	}
	function setInnerText(ele,text){
		if(typeof ele.textContent=='string'){
			ele.textContent=text;
		}else{
			ele.innerText=text;
		}
	}
	setInnerText(con1,'你好读者');

* outerText属性

* 读取模式：将字文档树中的所有文本拼接起来  

* 写入模式：替换调用元素及其子节点树的所有元素

* 还有ie4+,safari3+,opera10+,chrome