###目录

* [querySelector()方法](#a1)
* [querySelectorAll()方法](#a2)
* [matchesSelector()方法](#a3)
* [元素遍历](#a4)
* [HTML5 getElementsByClassName（）](#a5)
* [classList属性](#a6)
* [焦点管理](#a7)
* [HTMLDocument的变化](#a8)
* [字符集属性](#a9)
* [自定义数据属性](#a10)
* [插入标记](#a11)
* [专有扩展](#a12)

#DOM扩展

###Selector API Level1

（ie>=8）

<a name="a1"></a>

####querySelector()方法

该方法接受一个CSS选择符，返回与该模式匹配的第一个元素的引用，

	var body=document.querySelector('body');
	var ys=document.querySelector('.d1class .f p');

<a name="a2"></a>

####querySelectorAll()方法

	/*
	 * querySelectorAll,返回匹配的元素的一个NodeList对象，
	 * 并且可以通过[]或item()法访问列表中的项
	 */
	var li=document.querySelectorAll('.ul ul li');
	li[0].style.color='red';
	li.item(1).style.color='blue';

<a name="a3"></a>

###Selector API Level2

	/*
	 * matchesSelector个浏览器对该方法的支持不同（ie>8）,如果调用元素与选择符匹配
	 * 返回true
	 */
	function matchesSelector(ele,sel){
		if(ele.matchesSelector){
			return ele.matchesSelector(sel);
		}else if(ele.msMatchesSelector){
			return ele.msMatchesSelector(sel);
		}else if(ele.mozMatchesSelector){
			return ele.mozMatchesSelector(sel);
		}else if(ele.webkitMatchesSelector){
			return ele.webkitMatchesSelector(sel);
		}else{
			throw new Error('not supported');
		}
	}
	var mm=matchesSelector(document.body,'.page');
	alert(mm);

<a name="a4"></a>

###元素遍历

为了避免有些浏览器将空格当成文本节点返回，Element traversal API 定义了五个属性：（注意这五个属性都是DOM元素的属性）

+ childElementCount ，返回子元素的个数（不包括空文本节点和注释）

+ firstElementChild,指向第一个子元素

+ lashElementChild，指向最后一个子元素

+ previousElementSibling，指向前一个同辈元素

+ nextElementSibling，指向后一个同辈元素

<a name="a5"></a>

##html5

###getElementsByClassName（）

	/*
	 * getElementsByClassName(),(ie>=9)改方法接受一个参数
	 * 如下面所示，参数里面的css样式的顺序不重要，返回具有c1,c2,c3
	 * 这三个样式的一个HTMLCollection object
	 */
	var td=document.getElementsByClassName('c1 c3 c2');
	document.writeln(td);

<a name="a6"></a>

###classList属性

	/*
	 * 传统方法操作类名（ie9+）
	 */
	var td0=document.getElementsByClassName('c4 c5 c6');
	var cn=td0[0].className.split(/\s/);
	var pos=-1,i,len;
	for(i=0,len=cn.length;i<len;i++){
		if(cn[i]=='c4'){
			pos=i;
			break;
		}
	}
	cn.splice(i,1);
	td0.className=cn.join("");
	alert(cn);

	/*
	 * classList属性，返回引用元素的类的一个类集合，支持的浏览器
	 * firefox3.6+和chrome
	 */
	var td1=document.querySelector('.c7');//获得一个html元素的引用
	document.writeln(td1.classList.length);//调用classList属性，显示该元素的类的个数
	document.writeln(td1.classList[0]);//访问类集合的第一个项
	document.writeln(td1.classList.item(1));

	td1.classList.add('c1');//添加一个类，如果本来有则不添加
	document.writeln(td1.classList.contains('c3'));//检查集合中是否有给定的类，有则返回true，没有返回false
	td1.classList.remove('c9');//删除给定的类名
	td1.classList.toggle('c5');//

<a name="a7"></a>

###焦点管理

	/*
	 * document.activeElement属性，始终引用当前DOM中获
	 * 得焦点的元素,hasFocus()方法用于判断某各元素是否获得焦点，
	 * 返回布尔值
	 * 
	 * ie4+，firefox3+,safari4+,chrome,opera8+
	 */
	var btn1=document.getElementById('btn1');
	btn1.focus();
	document.writeln(document.activeElement==btn1);
	document.writeln(document.hasFocus());

<a name="a8"></a>

###HTMLDocument的变化
	
	/*
	 * document.readyState判断文档的加载情况
	 * ie4+，firefox3.6+,safari,chrome,opera9+
	 */
	if (document.readyState == 'loading') {
        alert('正在加载');
    }
    window.onload = function() {
        if (document.readyState == "complete") {
            li[0].style.color = 'black';
        }
    };

    /*
	 * 浏览器的渲染模式：CSS1Compat(标准模式)，BackCompat(混杂模式)
	 * ie6+，firefox+,safari3.1,chrome,opera
	 */
	document.writeln(document.compatMode);

	/*
	 * 获得<head>元素的引用
	 * safari5,chrome
	 */
	var head=document.head||document.getElementsByTagName('head')[0];
	alert(head);

<a name="a9"></a>

###字符集属性

	/*
	 * document.charset，获得文档的编码方式
	 * ie，safari,chrome,opera
	 * document.defaultCharset，浏览器的默认编码
	 * ie，safari,chrome
	 */
	document.writeln(document.charset);
	document.charset='utf-8';
	document.writeln(document.defaultCharset);

<a name="a10"></a>

###自定义数据属性

	/*
	 * dataset访问自定义属性，dataset是DOMStringMap的一个实例
	 */
	myd=document.querySelector('.data');
	document.writeln(myd.dataset.myshuxing);
	myd.dataset.sx='xinxin';

<a name="a11"></a>

###插入标记

####innerHTML属性

不支持的属性col,colgroup,frameset,head,html,style,table,tbody,thead,tfoot,tr

	/*
	 * innerHTML属性读取模式下返回调用该属性的所有子元素节点，包括注释节点，
	 * 写入模式下，传入的值被解析为DOM子树，替换调用元素的所有子节点
	 */
	alert(document.body.innerHTML);
	var cs1=document.querySelector('.c10');
	cs1.innerHTML='hhhhhhh';
	cs1.innerHTML="<a href='#'>测试</a>";//改属性可以解析HTML代码
	/*
	 * 下面的一行，不会被解析，<script>元素被认为是无作用域的元素，即页面中
	 * 看不到的元素,相同的元素还有注释等元素，如果innerHTML的值
	 * 是一个无作用域的元素，这个值会被解析为空字符串
	 */
	cs1.innerHTML="<script type='text/javascript' defer>alert('hi);<\/script>";
	/*
	 * 想让上面的代码能被解析，正常运行，需要给无作用域的元素前面加一个有作用域的元素标签
	 */
	cs1.innerHTML="_<script type='text/javascript'>alert('hi);<\/script>";
	cs1.innerHTML="<div>&nbsp;</div><script type='text/javascript'>alert('hi);<\/script>";
	/*
	 * 大部分浏览器支持下面的第一行代码，ie8及以下不支持，因为在ie8一下浏览器认为<style>
	 * 是没有作用域的元素,解决办法可以像上面的<script>一样
	 */
	cs1.innerHTML="<style type=\'text/css\'>body{background-color:green;}</style>";
	cs1.innerHTML="_<style type=\'text/css\'>body{background-color:green;}</style>";

####outerHTML属性

	/*
	 * outerHTML属性读取模式下返回调用它的元素的以及调用元素的
	 * 所有后代节点的html标签,在写入模式下，接受一个字符串参数，
	 * 然后把参数解析为HTML代码，替换调用的元素
	 * ie4+，firefox8+,safari4+,chrome,opera8+
	 */
	var outh=document.querySelector('.outerhtml .box');
	// alert(outh.outerHTML);
	outh.outerHTML="<div class='tihuanbox'>替换节点</div>";

###insertAdjacentHTML()方法

	/*
	 * insertAdjacentHTML()方法，在指定位置插入代码
	 * ie，firefox8+,safari,chrome,opera8+
	 */
	var iah=document.querySelector('.iah .iahbox');
	iah.insertAdjacentHTML('beforebegin','<p>你好，beforebegin，在调用元素的前面插入一个同辈的元素</p>');
	iah.insertAdjacentHTML('afterbegin','<p>你好，afterbegin，将字符串插入到调用元素的第一个子元素</p>');
	iah.insertAdjacentHTML('beforeend','<p>你好，beforeend，将字符串插入到调用元素的最后一个子元素</p>');
	iah.insertAdjacentHTML('afterend','<p>你好，afterend，在调用元素的后面插入一个同辈的元素</p>');

####scrollIntoView（）方法

	/*
	 * scrollIntoView（）方法让元素可见
	 * 该方法接受一个布尔值参数
	 * true/无参数：调用元素的顶部与视口顶部尽可能平齐
	 * false：调用元素尽可能全部出现在视口中
	 * ie，firefox,safari,opera
	 */
	var scroll=document.querySelector('.scroll');
	scroll.scrollIntoView(true);

<a name="a12"></a>

###专有扩展

####documentMode文档模式

	/*
	 * 判断ie的渲染模式
	 */
	var mode=document.documentMode;
	document.writeln(mode);

####children属性

	/*
	 * children属性，为了解决ie9之前的版本在处理空文本节点时候的差异
	 * ie5+，firefox3.5,safari2（有bug）,safari3，opera8,chrome
	 */
	var childc=document.querySelector('.ul0 ul').children.length;
	document.writeln(childc);

####contains（）

	/*
	 * 测试括号里面的元素是不是调用元素的后代
	 * ie,firefox9+,safari,opera,chrome
	 */
	var ul0=document.getElementById('ulid');
	document.body.contains(ul0);
	
	/*
	 * compareDocumentPosition()方法
	 * 返回关系掩码：
	 * 1：无关
	 * 2：居前
	 * 4：居后
	 * 8：包含
	 * 16：被包含
	 * ie9+,firefox,safari,opera9.5+,chrome
	 */
	var r1=document.body.compareDocumentPosition(ul0);
	var r2=ul0.compareDocumentPosition(document.body);
	alert(!!(r1&16));
	/*
	 * 通用方法
	 */
	var body=document.body;
	function contain(refnode,othernode){
		if(typeof refnode.contains=='function'&&(!client.engine.webkit || client.engine.webkit>=522)){
			return refnode.contains(othernode);
		}else if(typeof refnode.compareDocumentPosition=='function'){
			return !!(refnode.compareDocumentPosition(othernode));
		}else{
			var node=othernode.parentNode;
			do{
				if(node===refnode){
					return true;
				}else{
					node=node.parentNode;
				}
			}while(node!==null);
			return false;
		}
	}
	var result=contain(body,ul0);

###插入文本

* innerText属性     

* 读取模式：将字文档树中的所有文本拼接起来     

* 写入模式：     
* 删除调用元素的所有子节点，插入值     

* ie4+,safari3+,opera8+,chrome     

	
	下面的值不会被解析成html代码插入，
	con1.innerText="你好<b>\'reader\'</b>";

* Firefox支持textContent

* 还有ie9+,safari3+,opera10+,chrome

**通用方法**

	function getInnerText(ele){
		return(typeof ele.textContent=='string')?ele.textContent:ele.innerText;
	}
	function setInnerText(ele,text){
		if(typeof ele.textContent=='string'){
			ele.textContent=text;
		}else{
			ele.innerText=text;
		}
	}
	setInnerText(con1,'你好读者');

* outerText属性

* 读取模式：将字文档树中的所有文本拼接起来  

* 写入模式：替换调用元素及其子节点树的所有元素

* 还有ie4+,safari3+,opera10+,chrome